"""
Aratta CLI — init wizard, server launcher, health checks.

Usage:
    aratta init                          Interactive setup wizard
    aratta init --providers ollama,openai Non-interactive setup
    aratta serve                         Start the API server
    aratta health                        Check provider health
    aratta models                        List available models
"""

from __future__ import annotations

import argparse
import asyncio
import os
import sys
from pathlib import Path

# ---------------------------------------------------------------------------
# Lazy imports — keep startup fast
# ---------------------------------------------------------------------------


def _rich_available() -> bool:
    try:
        import rich  # noqa: F401
        return True
    except ImportError:
        return False


# ---------------------------------------------------------------------------
# Constants
# ---------------------------------------------------------------------------

PROVIDERS_CLOUD = ["anthropic", "openai", "google", "xai"]
PROVIDERS_LOCAL = ["ollama", "vllm", "llamacpp"]
ALL_PROVIDERS = PROVIDERS_LOCAL + PROVIDERS_CLOUD

API_KEY_ENV_MAP = {
    "anthropic": "ANTHROPIC_API_KEY",
    "openai": "OPENAI_API_KEY",
    "google": "GOOGLE_API_KEY",
    "xai": "XAI_API_KEY",
}

LOCAL_DEFAULTS = {
    "ollama": "http://localhost:11434",
    "vllm": "http://localhost:8000",
    "llamacpp": "http://localhost:8080",
}

TOML_TEMPLATE = '''\
# Aratta configuration — generated by `aratta init`
# Docs: https://github.com/scri-labs/aratta#configuration

[server]
host = "0.0.0.0"
port = 8084

[behaviour]
default_provider = "{default_provider}"
prefer_local = true
enable_fallback = true

{provider_sections}
{local_sections}
[aliases]
# Add your own shortcuts here
# my-model = "ollama:llama3.1:8b"
'''


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def _print(msg: str = "", style: str = ""):
    """Print with optional rich styling, falls back to plain print."""
    if _rich_available() and style:
        from rich import print as rprint
        rprint(f"[{style}]{msg}[/{style}]")
    else:
        print(msg)


def _prompt(label: str, default: str = "", secret: bool = False) -> str:
    """Prompt for input with optional default."""
    suffix = f" [{default}]" if default else ""
    try:
        if secret:
            import getpass
            value = getpass.getpass(f"{label}{suffix}: ")
        else:
            value = input(f"{label}{suffix}: ")
    except (EOFError, KeyboardInterrupt):
        print()
        sys.exit(0)
    return value.strip() or default


def _multi_select(label: str, options: list[str], defaults: list[str] = None) -> list[str]:
    """Simple multi-select prompt."""
    defaults = defaults or []
    print(f"\n{label}")
    for i, opt in enumerate(options, 1):
        marker = "*" if opt in defaults else " "
        print(f"  [{marker}] {i}. {opt}")
    print()
    raw = _prompt("Enter numbers separated by commas (or 'all')", ",".join(str(i + 1) for i, o in enumerate(options) if o in defaults))
    if raw.lower() == "all":
        return list(options)
    selected = []
    for part in raw.split(","):
        part = part.strip()
        if part.isdigit():
            idx = int(part) - 1
            if 0 <= idx < len(options):
                selected.append(options[idx])
    return selected or defaults


# ---------------------------------------------------------------------------
# Config writer
# ---------------------------------------------------------------------------

def _write_config(
    home: Path,
    providers: list[str],
    api_keys: dict[str, str],
    local_endpoints: dict[str, str],
    default_provider: str,
):
    """Write ~/.aratta/config.toml and .env."""
    home.mkdir(parents=True, exist_ok=True)

    # Build provider TOML sections
    provider_sections = []
    for p in PROVIDERS_CLOUD:
        if p in providers:
            provider_sections.append(f"[providers.{p}]\nenabled = true")
        else:
            provider_sections.append(f"[providers.{p}]\nenabled = false")

    local_sections = []
    for p in PROVIDERS_LOCAL:
        if p in providers:
            endpoint = local_endpoints.get(p, LOCAL_DEFAULTS.get(p, ""))
            local_sections.append(f'[local.{p}]\nenabled = true\nbase_url = "{endpoint}"')
        else:
            local_sections.append(f"[local.{p}]\nenabled = false")

    toml_content = TOML_TEMPLATE.format(
        default_provider=default_provider,
        provider_sections="\n\n".join(provider_sections),
        local_sections="\n\n".join(local_sections),
    )

    config_path = home / "config.toml"
    config_path.write_text(toml_content, encoding="utf-8")

    # Write .env
    env_lines = ["# Aratta API keys — generated by `aratta init`\n"]
    for provider, env_var in API_KEY_ENV_MAP.items():
        key = api_keys.get(provider, "")
        if key:
            env_lines.append(f"{env_var}={key}")
        else:
            env_lines.append(f"# {env_var}=")

    env_path = home / ".env"
    env_path.write_text("\n".join(env_lines) + "\n", encoding="utf-8")

    return config_path, env_path


# ---------------------------------------------------------------------------
# Health check
# ---------------------------------------------------------------------------

async def _check_provider_health(name: str, base_url: str, api_key: str | None = None) -> dict:
    """Ping a provider endpoint and return health status."""
    import httpx

    headers: dict[str, str] = {}
    check_url = base_url

    # Provider-specific health check URLs
    if name == "ollama":
        check_url = f"{base_url}/api/tags"
    elif name in ("vllm", "llamacpp"):
        check_url = f"{base_url}/v1/models"
    elif name == "anthropic":
        # Can't easily health-check without spending tokens; just check reachability
        check_url = "https://api.anthropic.com/v1/messages"
        headers = {"x-api-key": api_key or "", "anthropic-version": "2023-06-01", "Content-Type": "application/json"}
    elif name == "openai":
        check_url = "https://api.openai.com/v1/models"
        headers = {"Authorization": f"Bearer {api_key or ''}"}
    elif name == "google":
        check_url = f"https://generativelanguage.googleapis.com/v1beta/models?key={api_key or ''}"
    elif name == "xai":
        check_url = "https://api.x.ai/v1/models"
        headers = {"Authorization": f"Bearer {api_key or ''}"}

    try:
        async with httpx.AsyncClient(timeout=10.0) as client:
            resp = await client.get(check_url, headers=headers)
            healthy = resp.status_code < 400
            return {"provider": name, "status": "healthy" if healthy else "degraded", "code": resp.status_code, "latency_ms": resp.elapsed.total_seconds() * 1000}
    except Exception as e:
        return {"provider": name, "status": "unreachable", "error": str(e)}


async def _run_health_checks(providers: list[str], api_keys: dict[str, str], local_endpoints: dict[str, str]) -> list[dict]:
    """Run health checks against all configured providers."""
    tasks = []
    for p in providers:
        if p in PROVIDERS_LOCAL:
            url = local_endpoints.get(p, LOCAL_DEFAULTS.get(p, ""))
            tasks.append(_check_provider_health(p, url))
        else:
            key = api_keys.get(p) or os.getenv(API_KEY_ENV_MAP.get(p, ""))
            url = {"anthropic": "https://api.anthropic.com", "openai": "https://api.openai.com/v1", "google": "https://generativelanguage.googleapis.com", "xai": "https://api.x.ai/v1"}.get(p, "")
            tasks.append(_check_provider_health(p, url, key))
    return await asyncio.gather(*tasks)


# ---------------------------------------------------------------------------
# Commands
# ---------------------------------------------------------------------------

def cmd_init(args):
    """Interactive (or non-interactive) init wizard."""
    from .config import ARATTA_HOME

    home = ARATTA_HOME

    _print("aratta init", "bold cyan")
    _print("Local-first AI toolkit setup\n", "dim")

    # Non-interactive mode
    if args.providers:
        providers = [p.strip() for p in args.providers.split(",")]
        api_keys: dict[str, str] = {}
        local_endpoints: dict[str, str] = {}
        if args.local_endpoint:
            for p in PROVIDERS_LOCAL:
                if p in providers:
                    local_endpoints[p] = args.local_endpoint
        default_provider = next((p for p in providers if p in PROVIDERS_LOCAL), providers[0] if providers else "ollama")
    else:
        # Interactive mode
        _print("Aratta treats local models as the foundation. Cloud is the fallback.", "bold")
        print()

        # Step 1: Local providers
        local_selected = _multi_select(
            "Which local providers do you want to enable?",
            PROVIDERS_LOCAL,
            defaults=["ollama"],
        )

        local_endpoints = {}
        for lp in local_selected:
            default_url = LOCAL_DEFAULTS[lp]
            url = _prompt(f"  {lp} endpoint", default_url)
            local_endpoints[lp] = url

        # Step 2: Cloud providers
        cloud_selected = _multi_select(
            "Which cloud providers do you want to enable?",
            PROVIDERS_CLOUD,
            defaults=[],
        )

        api_keys = {}
        for cp in cloud_selected:
            env_var = API_KEY_ENV_MAP[cp]
            existing = os.getenv(env_var)
            if existing:
                _print(f"  {cp}: found {env_var} in environment", "green")
                api_keys[cp] = existing
            else:
                key = _prompt(f"  {cp} API key (or press Enter to skip)", secret=True)
                if key:
                    api_keys[cp] = key

        providers = local_selected + cloud_selected
        default_provider = local_selected[0] if local_selected else (cloud_selected[0] if cloud_selected else "ollama")

    # Write config
    config_path, env_path = _write_config(home, providers, api_keys, local_endpoints, default_provider)
    _print(f"\nConfig written to {config_path}", "green")
    _print(f"API keys written to {env_path}", "green")

    # Health checks
    _print("\nRunning health checks...", "bold")
    results = asyncio.run(_run_health_checks(providers, api_keys, local_endpoints))

    healthy_count = 0
    for r in results:
        status = r["status"]
        name = r["provider"]
        if status == "healthy":
            healthy_count += 1
            latency = r.get("latency_ms", 0)
            _print(f"  {name}: healthy ({latency:.0f}ms)", "green")
        elif status == "degraded":
            _print(f"  {name}: degraded (HTTP {r.get('code', '?')})", "yellow")
        else:
            _print(f"  {name}: unreachable — {r.get('error', 'unknown')}", "red")

    _print(f"\n{healthy_count}/{len(results)} providers healthy. Default: {default_provider}", "bold")
    _print("Run `aratta serve` to start the API server.\n", "dim")


def cmd_serve(args):
    """Start the Aratta API server."""
    from .config import load_config

    config = load_config()
    host = args.host or config.host
    port = args.port or config.port

    _print(f"Starting Aratta on {host}:{port}", "bold cyan")

    import uvicorn
    uvicorn.run(
        "aratta.server:create_app",
        host=host,
        port=port,
        factory=True,
        reload=args.reload,
    )


def cmd_health(args):
    """Check health of configured providers."""
    from .config import load_config

    config = load_config()
    providers = config.get_available_providers()

    if not providers:
        _print("No providers configured. Run `aratta init` first.", "yellow")
        return

    _print("Checking provider health...\n", "bold")

    api_keys = {}
    local_endpoints = {}
    for name in providers:
        p = config.get_provider(name)
        if p and p.api_key_env:
            api_keys[name] = os.getenv(p.api_key_env, "")
        if p and name in PROVIDERS_LOCAL:
            local_endpoints[name] = p.base_url

    results = asyncio.run(_run_health_checks(providers, api_keys, local_endpoints))

    healthy = sum(1 for r in results if r["status"] == "healthy")
    for r in results:
        status = r["status"]
        name = r["provider"]
        if status == "healthy":
            _print(f"  {name}: healthy ({r.get('latency_ms', 0):.0f}ms)", "green")
        elif status == "degraded":
            _print(f"  {name}: degraded (HTTP {r.get('code', '?')})", "yellow")
        else:
            _print(f"  {name}: unreachable", "red")

    _print(f"\n{healthy}/{len(results)} providers healthy", "bold")


def cmd_models(args):
    """List configured model aliases."""
    from .config import load_config

    config = load_config()
    _print("Model aliases:\n", "bold")
    for alias, target in sorted(config.model_aliases.items()):
        _print(f"  {alias:20s} → {target}")
    _print(f"\nDefault provider: {config.default_provider}", "dim")


# ---------------------------------------------------------------------------
# Entry point
# ---------------------------------------------------------------------------

def main(argv: list[str] = None):
    """CLI entry point."""
    parser = argparse.ArgumentParser(
        prog="aratta",
        description="Aratta — universal AI API adapter, local first.",
    )
    sub = parser.add_subparsers(dest="command")

    # init
    p_init = sub.add_parser("init", help="Set up Aratta (interactive wizard)")
    p_init.add_argument("--providers", help="Comma-separated provider list (non-interactive)")
    p_init.add_argument("--local-endpoint", help="Local LLM endpoint URL")

    # serve
    p_serve = sub.add_parser("serve", help="Start the API server")
    p_serve.add_argument("--host", default=None)
    p_serve.add_argument("--port", type=int, default=None)
    p_serve.add_argument("--reload", action="store_true", help="Enable auto-reload")

    # health
    sub.add_parser("health", help="Check provider health")

    # models
    sub.add_parser("models", help="List model aliases")

    args = parser.parse_args(argv)

    if args.command == "init":
        cmd_init(args)
    elif args.command == "serve":
        cmd_serve(args)
    elif args.command == "health":
        cmd_health(args)
    elif args.command == "models":
        cmd_models(args)
    else:
        parser.print_help()


if __name__ == "__main__":
    main()
